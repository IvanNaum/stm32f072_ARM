## Задание 08 "rtc_alert"

### Описание RTC

RTC - real time clock - часы реального времени. Применяются для того, чтобы поддерживать, насколько это возможно, реальное время. В зависимости от настроек, часы RTC могут идти даже при выключенном контроллере, для этого необходимо поддерживать питание Vbat. Примерно для тех же целей у BIOS'а компьютера есть своя батарейка.

У модуля RTC есть возможность будить МК и генерировать прерывания при определённых событиях (вроде совпадения числа секунд, минут, часов, числа или дня недели с заданными). Таким образом можно реализовать в некоторых проектах периодические задачи, которые надо производить, например, раз в день, а всё остальное время спать, чтобы не тратить энергию.

### Настройка RTC

Первым делом подключаем тактирование:

```c
    LL_RCC_LSI_Enable();
    while (LL_RCC_LSI_IsReady() != 1);

    LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_PWR);
    LL_PWR_EnableBkUpAccess(); // для возможности изменять источник тактирования для RTC (сброс настроек RTC)

    LL_RCC_SetRTCClockSource(LL_RCC_RTC_CLKSOURCE_LSI);
    LL_RCC_EnableRTC();
```

В нашем случае мы используем LSI с частотой 40kHz - он не тикает при выключенном контроллере, для наших целей его достаточно. Если необходимо, чтобы часы шли при выключенном контроллере, нужно выбрать LSE и подлючить резонатор на 32.768kHz: он тикает в любом состоянии, если подключено питание.

Настройка часов модуля обёрнута в функции `LL_RTC_DisableWriteProtection(RTC)` и `LL_RTC_EnableWriteProtection(RTC)` для того, чтобы снять защиту от случайной записи и вернуть её обратно после настройки. Так же необходимо находиться в режиме инициализации (Init mode):

```c
    LL_RTC_DisableWriteProtection(RTC);
    LL_RTC_EnableInitMode(RTC); // начало инициализации
    while (!LL_RTC_IsActiveFlag_INIT(RTC));

    // инициализация

    LL_RTC_DisableInitMode(RTC); // конец инициализации - дальше часы просто идут
    LL_RTC_EnableWriteProtection(RTC);
```

Настройка предделителей:

```c
    LL_RTC_SetAsynchPrescaler(RTC, 0x7F);
    LL_RTC_SetSynchPrescaler(RTC, 0x0137);
```

В данном случае, предделители настроены так, что после них на выходе получаются нужные для RTC 1Hz. Рекомендовано иметь максимально возможный показатель на асинхронном делителе частоты - 0x7F, остальное до необходимой частоты настраивается на синхронном.

Выставление даты и времени:

```c
    LL_RTC_SetHourFormat(RTC, LL_RTC_HOURFORMAT_24HOUR);
    LL_RTC_DATE_Config(RTC, LL_RTC_WEEKDAY_FRIDAY, 10,
                       LL_RTC_MONTH_MAY, 0x2020);
    LL_RTC_TIME_Config(RTC, LL_RTC_TIME_FORMAT_AM_OR_24, 0x18, 0x30, 00);
```

Все числа в регистрах модуля RTC хранятся в формате BCD: на каждую десятичную цифру уходит 4 бита, т.е. время 18:30 запишется как 0x18 в байт для часов и 0x30 в байт для минут.

![Пример записи в BCD](https://github.com/leokondrashov/stm32f0_ARM/blob/dev/docs/images/BCD.png)

Стоит помнить, что эта инициализация происходит при каждом включении МК. То есть, каждый запуск будет начинаться для МК в 18:30:00 10 мая 20 года (RTC запоминает только последнии две цифры года).

Настройка будильника:

```c
    LL_RTC_DisableWriteProtection(RTC);

    LL_RTC_ALMA_Disable(RTC);
    while (!LL_RTC_IsActiveFlag_ALRAW(RTC));
    LL_RTC_ALMA_SetMask(RTC, LL_RTC_ALMA_MASK_ALL); // выставление маски активных событий
    //LL_RTC_ALMA_ConfigTime(RTC, LL_RTC_ALMA_TIME_FORMAT_AM, 00, 00, 00);
    LL_RTC_ALMA_Enable(RTC);
    LL_RTC_EnableIT_ALRA(RTC);

    LL_RTC_EnableWriteProtection(RTC);
```

`LL_RTC_ALMA_SetMask(RTC, LL_RTC_ALMA_MASK_ALL)` - выставляет будильник на любое изменение времени (по сути, срабатывает каждую секунду). Изменив маску, можно получать сигнал с будильника раз в минуту/час/день/неделю/месяц. В таком случае необходимо раскомментировать строку с `ConfigTime` и выставить то время, в которое надо, чтобы сработал будильник.

Далее, осталось только включить нужное прерывание в NVIC, учитывая то, что прерывание от RTC находится на 17 линии EXTI:

```c
    NVIC_EnableIRQ(RTC_IRQn);
    NVIC_SetPriority(RTC_IRQn, 0);
    LL_EXTI_EnableIT_0_31(LL_EXTI_LINE_17);
    LL_EXTI_EnableFallingTrig_0_31(LL_EXTI_LINE_17);
    LL_EXTI_EnableRisingTrig_0_31(LL_EXTI_LINE_17);
```

### Использование RTC

Во-первых, теперь у нас есть возможность делать что-либо ровно раз в секунду (с точностью до стабильности частоты). В нашем коде, раз в секунду переключается синий светодиод по прерывании от будильника:

```c
void RTC_IRQHandler(void)
{
    LL_GPIO_TogglePin(GPIOC, LL_GPIO_PIN_8);

    LL_RTC_ClearFlag_ALRA(RTC);
    LL_EXTI_ClearFlag_0_31(LL_EXTI_LINE_17);
}
```

Во-вторых, у модуля RTC можно спросить, который сейчас час и какое сегодня число. (Эти числа будут в формате BCD, но есть макросы в библиотеке LL для правильного перевода в обычные числа):

```c
    time = LL_RTC_TIME_Get(RTC);
    date = LL_RTC_DATE_Get(RTC);
```

### Обязательное задание

Сделайте:
1. сброс времени на модуле RTC на заданное по какому-либо внешнему событию (например, нажатие кнопки), а не при reset, как это происходит в коде лабораторной. 
2. генерацию прерываний с заданной частотой (например, раз в минуту или час).

### Дополнительное задание

В качестве задания повышенной сложности сделайте часы с возможностью выставления времени и будильником.
